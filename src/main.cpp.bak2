#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <getopt.h>
#include <fstream>
#include <zconf.h>
#include <thread>
#include <ares_build.h>
#include <netinet/in.h>
#include "../libtehs/forkProcess.h"


using namespace std;

static int isKillFlag = 0;
#define PORT 8080
#define QUEUE 20
int conn;

struct option longopts[] = {
    {"fork",  no_argument, NULL, 'f'},
    {"stop", no_argument, NULL, 's'},
    {"load", no_argument, NULL, 'L'},
    {"help", no_argument, NULL, 'h'},
    {0,       0,             0,      0},
};

void usage() {
  fprintf(stderr,
          "\n"
          "Usage: pat [options]\n"
          "\n"
          "Options:\n"
          "    -f, --fork       fork a child process\n"
          "    -s, --stop     "
          "stop the child process\n"
          "    -t, --thread     spawn new thread\n"
          "    -l, --list      list all child process\n"
          "    -h, --help      help\n");

  exit(0);
}



void saveStopFlag(int Flag) {
  char filename[40];
  char homeSrc[50] = "/home/zyx/workspace/process_and_thread";
  sprintf(filename, "%s/config/killflag",homeSrc);

  ofstream outfile;
  outfile.open(filename, std::ifstream::out);

  if (!outfile.is_open()) {
    printf("killflag file open failed....");
    exit(1);
  }

  outfile << Flag;
  outfile.close();
}

int charToInt(char flagChar){
  char flagString[10];
  flagString[0] = flagChar;
  return (int)flagString[0];
}


int getStopFlag(){
  char filename[40];
  char homeSrc[50] = "/home/zyx/workspace/process_and_thread";
  sprintf(filename, "%s/config/killflag",homeSrc);

  ifstream infile;
  infile.open(filename, std::ifstream::in);

  if (!infile.is_open()) {
    printf("killflag file open failed....");
    exit(1);
  }

  char flagString[10];
  int flag;
  char flagChar = infile.get();
  flag = charToInt(flagChar);

  return flag;
}


void saveClient(int conn, char *buffer, int len){
  char connAndLenConfig[50];
  char buffConfig[50];
  char homeSrc[50] = "/home/zyx/workspace/process_and_thread";

  //设置文件位置
  sprintf(connAndLenConfig, "%s/config/conn",homeSrc);
  sprintf(buffConfig, "%s/config/buffer",homeSrc);

  //保存conn和len
  ofstream savConnAndLen;
  savConnAndLen.open(connAndLenConfig, std::ofstream::app);

  if (!savConnAndLen.is_open()){
    printf("conn file open failed...\n");
  }

  savConnAndLen<<conn<<"\n";
  savConnAndLen<<len;
  savConnAndLen.close();

  //保存buffer
  ofstream savBuffer;
  savBuffer.open(buffConfig, std::ofstream::app);

  if (!savBuffer.is_open()){
    printf("buff file open failed...\n");
  }

  savBuffer<<buffer<<"\n";
  savBuffer.flush();
  savBuffer.close();
}

void getClient(int conn, char *buffer, int len){
  char connAndLenConfig[50];
  char buffConfig[50];
  char homeSrc[50] = "/home/zyx/workspace/process_and_thread";

  //设置文件位置
  sprintf(connAndLenConfig, "%s/config/connAndLen",homeSrc);
  sprintf(buffConfig, "%s/config/buffer",homeSrc);

  //保存conn和len
  ifstream ConnAndLen;
  ConnAndLen.open(connAndLenConfig, std::ifstream::in);

  if (!ConnAndLen.is_open()) {
    printf("connAndLen file open failed....");
    exit(1);
  }

  char strVec[2];
  int i = 0;
  while (ConnAndLen.getline(strVec,2)){
    printf("%d:%s",i,strVec[i]);
    i++;
  }
  printf("%s",strVec[0]);
  ConnAndLen.close();

}

[[noreturn]] void  childActive(){
//  while (true){
//
//    if (getStopFlag()){
//      saveStopFlag(0);
//      break;
//    }
//
//    sleep(2);
//  }
//  send(conn,buffer,sizeof(buffer),0);
//  close(conn);
//  while (true) {
//    int conn;
//    char *buffer;
//    int len;
//    getClient(conn, buffer, len);
//  }
}

void parentActive(){
  int serSocket = socket(AF_INET, SOCK_STREAM, 0);

  //server socket
  struct sockaddr_in sockaddr;
  sockaddr.sin_family = AF_INET;
  sockaddr.sin_port = htons(PORT);
  sockaddr.sin_addr.s_addr =INADDR_ANY;

  //判断bind是否成功
  if(bind(serSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == -1) {
    printf("bind error...\n");
    exit(1);
  }

  //监听判断
  if(listen(serSocket, QUEUE) == -1){
    printf("listen error...");
    exit(1);
  }

  //client socket
  struct sockaddr_in clientaddr;
  socklen_t socklen = sizeof(clientaddr);

  //接受 accept返回值
  conn = accept(serSocket, (struct sockaddr*)&clientaddr, &socklen);

  //判断是否成功
  if(conn < 0){
    printf("accept error...");
    exit(1);
  }

  char buffer[1024];

  //接收client发送的消息
  while (true){

    //消息格式化
    memset(buffer,0,sizeof(buffer));

    //接收消息
    int len = recv(conn,buffer,sizeof(buffer),0);

    if(strcmp(buffer,"exit\n") == 0){
      break;
    }

    printf("%s\n", buffer);

    printf("%d\n", conn);

    printf("%d\n", len);

    saveClient(conn,buffer,len);
    //创建线程来处理文件
//    std::thread thread (saveClient,conn,buffer,len);
//    std::thread::id thread_id;
//    thread_id = thread.get_id();
//    printf("%d\n",thread_id);

    close(serSocket);
  }
}

//[[noreturn]] void thread_active(){
//  printf("this is thread...");
//}

void stop() {
  isKillFlag = 1;
//  childPid = pid;

  saveStopFlag(isKillFlag);

  exit(1);
}



int main(int argc, char *argv[] ) {
  int opt = 0;

  while (-1 !=
      (opt = getopt_long(argc, argv, "::alLh::c:d:", longopts, NULL))
      ) {
    switch (opt) {
      case 'f':
        forkProcess((active_t) childActive,(active_t) parentActive);
        break;
      case 's':stop();
        break;
      case 'h':usage();
        break;
      case 't':
//        creatThread();
        break;
      case 'l':

        break;
      case '?':usage();
        break;
      default:usage();
        break;
    }
  }

}